## 类与对象

单独使用定义变量的方式和数组的方式进行大量数据的管理，效率低下

在面向对象中，我们使用对象来体现各种各样的事物，对象中有两个关键的内容：属性（内在的特征，与自身关联，如年龄，名字等）和行为（行为方法。如修改名称等），将属性提取出来，就形成了一个类（类是一个数据类型）

类与对象的关系示意图：

![image-20250327104828374](..\assets\image-20250327104828374.png)

> 将猫类的所有属性提取出来，形成一个猫类的数据类型（自己定义的数据类型，`int`是`Java`系统提供的数据类型），这个数据类型有以下常用的属性：`name`、`age`等，当然所有的猫都有行为，如：跑、叫和吃等
>
> 对于一个猫类，我们可以使用这个类定义许多的猫，这些猫就是对象（简而言之，我们可以通过猫类来创建猫对象，即创建一只具体的猫）

```java
// 定义一个猫类（自定义的数据类型）
class Cat {
    String name;
    int age;
    String color;
}

// 使用OOP面向对象解决
// 实例化一只猫对象
Cat cat1 = new Cat();
// 为对象添加属性
cat1.name = "小白";
cat1.age = 3;
cat1.color = "白色";
```

综上所述：类就是一个数据类型，对象就是一个具体的实例，从类到对象有几种说法：

- 创建了一个对象
- 实例化一个对象
- 把类实例化

***

### 对象的内存布局

`Java`内存的结构分析：

- 栈：一般存放基本数据类型（局部变量）
- 堆：存放对象（自定义类，数组等）
- 方法区：常量池（常量、比如字符串），类的加载信息（自定义的类信息只会加载一次）

对象在内存中的存在形式（重要）：

![image-20250327111603422](..\assets\image-20250327111603422.png)

> 字符串是一个引用类型，在堆中存放的是地址，实际上将数据放在方法区中的常量池中，基础数据类型的值会直接存放到堆中
>
> 在执行实例化对象的时候，会将类的信息（属性信息和方法信息）加载到方法区中
>
> `Java`创建对象流程的简单分析：
>
> 1. 先加载`Cat`类信息（属性和方法信息，只会加载一次）
> 2. 在堆中分配空间，进行默认初始化（和数组初始化类似）
> 3. 把地址赋值给`cat`（创建的对象名），对象名就指向这个对象
> 4. 进行指定初始化，如`cat.age = 12;`

将实例化的对象赋值给另一个对象名，`Person p2 = p1;`   把`p1`赋值给了`p2`，或者说让`p2`指向`p1`，是引用类型，实现的是地址拷贝，指向的都是同一个堆中的对象，其内存分配过程如下：

![image-20250327131535351](..\assets\image-20250327131535351.png)

小练习：

![image-20250327132602592](..\assets\image-20250327132602592.png)

***

### 属性的概念

属性也叫成员变量，或者叫`field`字段，属性是类的一个组成部分，一般是基本数据类型，也可以是引用类型（对象、数组）

```java
public class Object {
    // main方法
    public static void main(String[] args) {
        // 实例化一个对象
        // cat1是对象名，new Cat()是真正的对象，在堆中创建了对象空间，将地址与对象名的指向地址联系起来
        Cat cat1 = new Cat();
        // 访问属性
        cat1.name;
    }
}

// 定义一个猫类（自定义的数据类型）
class Cat {
    // 定义属性/成员变量
    String name;
    int age;
    String color;
    String[] master;  // 属性可以是引用数据类型
}
```

注意事项：

- 属性的定义语法同变量的定义，但是多了一个访问修饰符的概念：`访问修饰符 属性类型 属性名;`

  访问修饰符是用于控制属性的范围，有四种访问修饰符：`public`、`proctected`、`默认情况`、`private`

- 属性的定义类型可以为任意类型，包含基本类型或引用类型

- 属性如果不赋值，有默认值，规则和数组一致

***

### 方法的概念

成员方法的定义：

```java
访问修饰符 返回的数据类型 方法名(形参列表..) {
    方法体语句;
    return 返回值;
}
```

> - 访问修饰符：控制方法的使用范围，常用的方法修饰符有四个
>
> - 形参列表：表示成员方法的输入
>
>   - 一个方法可以有0个参数，也可以有多个参数，中间使用逗号隔开
>   - 参数类型可以为任意类型，包含基本类型或引用类型，同一列表的参数类型可以是不同的类型
>   - 调用参数的方法时，一定对应着参数列表传入相同类型或兼容类型（可以进行自动转换）的参数
>   - 方法定义时的参数称为形式参数，简称行参；方法调用时传入的参数称为实际参数，简称实参，实参和形参的类型要一致或兼容，个数、顺序必须一致
>
> - 返回的数据类型：表示成员方法输出，`void`表示没有返回值，返回的类型可以为任意类型，包含基本类型和引用类型，但是接收返回值时，需要声明与返回值同类型的变量去接收
>
>   一个方法最多只有一个返回值，如果需要多个返回值，我们可以返回数组
>
>   ```java
>   // 返回两个数的和差
>   class Num {
>       public int[] getSumAndSub(int n1, int n2) {
>           int res[] = new int[2];
>           res[0] = n1 + n2;
>           res[1] = n1 - n2;
>           return res;
>       }
>   }
>   ```
>
> - 方法主体：表示为了实现某一功能代码块，可以为输入、输出、运算、分支、循环、方法调用，但是在方法主体中不能再定义方法，即：方法不能嵌套定义
>
> - `return`语句不是必须的，如果方法要求有返回数据类型，则方法体中最后的执行语句必须为`return`值，而且要求返回值类型必须和`return`的值类型一致或者兼容（可以自动转换的）
>
>   ```java
>   // 类型一样，编译通过
>   public double f1() {
>       return 1.1;
>   }
>   
>   // 兼容（可以自动转换），编译通过
>   public double f1() {
>       int n = 1;
>       return n;
>   }
>   
>   // 类型不一致，且不能自动转换，编译不通过
>   public int f1() {
>       return 1.1;
>   }
>   ```
>
>   如果方法是`void`，则方法中可以没有`return`语句，或者只写`return;`，但是不能返回具体的内容

成员方法简称为方法，用于声明一些具体的行为

```java
public class Object {
    // main方法
    public static void main(String[] args) {
        // 实例化一个对象
        Person person1 = new Person();
        // 调用方法
        person1.speak();
        person1.cal(6);
        int data = person1.getSum(3, 6);  // 将方法返回的值赋给data
    }
}

// 定义一个猫类（自定义的数据类型）
class Person {
    // 定义属性/成员变量
    String name;
    int age;
    // 定义方法/成员方法
    // public表示方法是公开的；void表示方法没有返回值；speak表示方法名
    public void speak() {
        System.out.println("我是一个好人");
    }
    // (int n)表示形参列表，表示当前有一个形参n，可以接收调用者的输入
    public void cal(int n) {
        int res = 0;
        for(int i; i <= n; i++) {
            res += i;
        }
        System.out.println("计算结果=" + res);
    }
    // 方法有返回值的形式
    // int表示方法执行后，返回一个int值
    public int getSum(int num1, int num2) {
        int res = num1 + num2;
        return res;
    }
}
```

方法调用机制的原理图：（重要）

![image-20250327135857719](..\assets\image-20250327135857719.png)

首先会在栈中创建一个栈空间（`main`栈空间），当执行了方法时，会在开辟一个独立的栈空间（栈和栈之间不会相互影响），进行形参的赋值，执行完方法后，会将结果进行返回，当返回之后，这个临时开辟的独立栈空间就会被释放

成员方法的好处：减少代码冗余，提高了代码的复用性；同时可以将实现的细节封装起来，然后供其他用户来调用

方法调用细节：

- 同一个类中的方法调用：直接调用即可

  ```java
  class A {
      public void print(int n) {
          System.out.println("print()方法被调用 n=" + n);
      }
      
      public void sayOk() {
          // 调用同一个类中的print()方法
          print(10);
      }
  }
  ```

- 跨类中的方法A类调用B类的方法：需要通过对象名调用，跨类的方法调用共和方法访问修饰符相关

  ```java
  class A {
      public void print(int n) {
          System.out.println("print()方法被调用 n=" + n);
      }
  }
  
  class B {
      public void sayOk() {
          // 创建一个A类的对象
          A a = new A();
          // 调用a对象的方法
          a.print(10);
      }
  }
  ```

***

#### 方法的传参机制

方法的传参机制在编程中是非常重要的：

- 对于基本数据类型的传参机制，传递的是值（值拷贝），形参的任何改变不影响实参

  ```java
  public class MethodParameter {
  	public static void main(String[] args) {
          int a = 10;
          int b = 20;
          // 实例化AA对象
          AA obj = new AA();
          obj.swap(a, b);
          System.out.prinln(a, b);    // 10 20
  	}
  }
  
  class AA {
      public void swap(int a, int b) {
          System.out.prinln(a, b);   // 10 20
          int temp = a;
          a = b;
          b = temp;
          System.out.prinln(a, b);   // 20 10
      }
  }
  ```

  通过内存来进行辅助理解：

  调用`obj.swap(a, b);`方法，传递的是10和20，`swap()`方法中接收的是10和20，两个栈是独立的空间，其基本数据类型的变量是不冲突的

- 对于引用数据类型的传参机制，传递的是地址（传递的也是值，但这个值是地址），形参的改变会影响实参

  ```java
  public class MethodParameter {
  	public static void main(String[] args) {
          int[] arr = {1, 2, 3};
          BB obj = new BB();
          obj.test(arr);    // 200 2 3
          
          // 遍历数组
          for(int i = 0; i < arr.length; i++) {
              System.out.print(arr[i] + "\t");
          }
          System.out.println();    // 200 2 3
  	}
  }
  
  class BB {
      public void test(int arr) {
          arr[0] = 200;   // 修改了传递进来的数组元素
          // 遍历数组
          for(int i = 0; i < arr.length; i++) {
              System.out.print(arr[i] + "\t");
          }
          System.out.println();
      }
  }
  ```

  ```java
  public class MethodParameter {
  	public static void main(String[] args) {
          Person p = new Person();
          p.name = "jlc";
          p.age = 25;
          BB b = new BB();
          b.test(p);
          System.out.println(p.age);   // 100
  	}
  }
  
  class Person {
      String name;
      int age;
  }
  
  class BB {
      public void test(Person p) {
          p.age = 100;
      }
  }
  ```

  小变化：

  ```java
  public class MethodParameter {
  	public static void main(String[] args) {
          Person p = new Person();
          p.name = "jlc";
          p.age = 25;
          BB b = new BB();
          b.test(p);
          System.out.println(p.age);   // 10
  	}
  }
  
  class Person {
      String name;
      int age;
  }
  
  class BB {
      public void test(Person p) {
          p = null;
      }
  }
  ```

  `BB`类中的将传入的`p`对象设置为`null`，是切断了当前方法栈空间中的`P`指向的堆中的对象，但是不会影响原先`main`栈空间中`p`的指向，`p`还是指向堆中的对象，因此，其值还是25

  ![image-20250327211100538](..\assets\image-20250327211100538.png)

***

### 克隆对象

克隆对象，要求新对象和原来对象是两个独立的对象，只是他们的属性和属性值完全相同

```java
public class MethodParameter {
	public static void main(String[] args) {
        Person p = new Person();
        p.name = "jlc";
        p.age = 25;
        MyTools myTools = new MyTools();
        Person p2 = myTools.copyPerson(p);
        // p和p2都是Person对象，但是是两个独立的对象，其属性和属性值相同
	}
}

class Person {
    String name;
    int age;
}

class MyTools {
    public Person copyPerson(Person p) {
        // 创建一个新对象
        Person p2 = new Person();
        p2.name = p.name;   // 将原来对象的名字赋值给p2.name
        p2.age = p.age;
        return p2;
    }
}
```





